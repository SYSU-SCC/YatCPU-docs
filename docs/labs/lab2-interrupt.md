# 中断

完成流水线 CPU 实验后，你就已经对基于流水线 CPU 的原理和设计有初步认识了。但是这个简单的 CPU 只能按照预先的程序指令一直运行，无法中途打断。然而，我们生活的世界充满了不确定性，一个实用的 CPU 需要能够时刻准备好处理来自外部的事件，及时处理中断，并返回到原来的程序中继续执行。

在本实验中，你将学习到：

- CSR 寄存器以及其操作命令
- 中断控制器的原理和设计
- 正确处理中断发生时流水线的状态
- 编写一个简单的定时中断发生器

## 中断控制器

中断控制器在每一个时钟周期都检查是否有来自外部的中断信号。一旦有中断信号拉起，CPU 清空流水线，然后在中断控制器设置好相关的 CSR 寄存器信息后，通过控制单元恢复流水线执行中断处理程序。

具体来说，中断控制器收到中断信号后，首先应当同时拉起 CPU 端的中断信号，提示 CPU 有中断发生，CPU 此时暂停执行。中断控制器将当前的指令地址保存到 `mepc` 寄存器中，然后将 `mstatus` 寄存器中的 `MPIE` 标志位设置为 `0`，禁用中断，避免中断嵌套，然后设置 `mtcause` 寄存器的值，以便中断处理程序获取中断发生的原因。最后，中断控制器读取 `mtvec` 寄存器的值，并将其设置为流水线的下一个指令地址，恢复 CPU 流水线执行。

模块的输入信号以及输出信号已经定义好，相关代码文件位于 `src/main/scala/riscv/core/CLINT.scala`，请在 `// Lab3(CLINTCSR)` 注释处填入代码，使其能通过 `CLINTCSRTest` 测试。